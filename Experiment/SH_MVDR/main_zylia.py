# -*- coding: utf-8 -*-
"""
Created on Sat Jul 20 16:32:04 2024

@author: sergiozc
@references:
    - https://www.zylia.co/white-paper.html

MVDR beamformer in the Spherical Harmonics domain using a signal generated by ZYLIA ZM-1 HO MICROPHONE
"""

from utils import utils
import numpy as np
from scipy.signal import resample
import pandas as pd
import matplotlib.pyplot as plt
from SH_visualize import SH_visualization
from SH_BF import sphericalBF
from sphericalHarmonic import SHutils
from scipy.io import wavfile
from pesq import pesq
from scipy.signal import welch

plt.close('all')

# %%
# PARAMETER DEFINITION

c = 343 # Propagation speed
r = 0.049 # Zylia radius
SH_order = 3 # Spherical harmonic order (it determines the complexity of the function)
# The higher is the order, the more directive is the beampattern
# Nevertheless, the higuer is the order, the  more spatial aliasing might we have
N_harm = (SH_order + 1) ** 2 # Highest number of harmonics

# Microphones' positions
pos_mic = pd.read_csv('input_data/zylia/pos_mics.txt')
el = np.array(np.deg2rad(pos_mic['el']))
az = np.array(np.deg2rad(pos_mic['az']))
Q = len(el) # Number of microphones
L = 1 # Number of sources

# Microphone positions (cartesian coordinates). Ref: https://www.zylia.co/white-paper.html
pos_mic_cart = np.array([
    [0.0, 0.0, 49.0],  # 1
    [32.7, 0.1, 36.5],  # 2
    [-16.4, 28.3, 36.5],  # 3
    [-16.3, -28.3, 36.5],  # 4
    [6.3, -45.8, 16.3],  # 5
    [36.6, -28.2, 16.3],  # 6
    [36.5, 28.4, 16.3],  # 7
    [6.2, 45.8, 16.3],  # 8
    [-42.8, 17.4, 16.3],  # 9
    [-42.7, -17.6, 16.3],  # 10
    [-36.5, -28.4, -16.3],  # 11
    [-6.2, -45.8, -16.3],  # 12
    [42.8, -17.4, -16.3],  # 13
    [42.7, 17.6, -16.3],  # 14
    [-6.3, 45.8, -16.3],  # 15
    [-36.6, 28.2, -16.3],  # 16
    [-32.7, -0.1, -36.5],  # 17
    [16.4, -28.3, -36.5],  # 18
    [16.3, 28.3, -36.5]  # 19
]) / 1000  # Meters


# Sources' positions (BY MUSIC METHOD)

# TEST 1
#az_s = np.array([2.303834612632515])
#el_s = np.array([0.802851455917392])

# TEST 2
az_s = np.array([0.785398163397448])
el_s = np.array([0.903755458911392])

# Load microphones' signals
# TEST 1
#y, fs = utils.load_wav_signals('input_data/zylia/')
# TEST 2
y, fs = utils.load_wav_signals('input_data/zylia/test2/')

#y = y[1:491009] # CAMBIAR PARA TEST 2

# Signal normalization (one mic)
y_before = y[:,1]/ np.max(np.abs(y[:,1]))
# Convert to 16-bit integer in order to save as a WAV
y_wav = np.int16(y_before * 32767)

# Saving the wav file

# TEST 1
# wavfile.write('./results/zylia/signal_before.wav', fs, y_wav)
# TEST 2
wavfile.write('./results/zylia/test2/signal_before.wav', fs, y_wav)

# Definir los parámetros para el cálculo de la PSD
nperseg = 1024  # Tamaño de cada segmento para la FFT
noverlap = nperseg // 2  # Cantidad de solapamiento entre segmentos
freq_array, y_psd = welch(y_before, fs, nperseg=nperseg, noverlap=noverlap, return_onesided=True, scaling='density', axis=0)

plt.figure()
plt.plot(freq_array, 10 * np.log10(y_psd))
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD (dB/Hz)')
plt.title('PSD of #1 mic recorded signal')
plt.grid()
plt.show()

#%% MICROPHONES VISUALIZATION
# Visualization of zylia geometry
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(pos_mic_cart[:, 0], pos_mic_cart[:, 1], pos_mic_cart[:, 2], c='b', marker='o')
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_title('Zylia array')
ax.set_box_aspect([1,1,1])  # Aspect ratio is 1:1:1
plt.show()

#%% MVDR Beamformer

# Sources Spherical Harmonics
Y_s = SHutils.realSH(SH_order, utils.el2inc(el_s), az_s) # d_n (steering vector)
# In SH domain, the steering vector of the beamformer is given by the spherical harmonics

# Power of the sources
power_s = np.eye(L) # We assume all sources have the same power


# Power of the noise (diffuse noise)
#power_noise = 1

# Power of the noise (within the record)
power_noise = np.var(y_before[0:150000]) # Noise samples (without voice)

# SH signal covariance matrix (N_harm x N_harm)
cov_matrix = sphericalBF.SH_COV(N_harm, Y_s, power_s, power_noise)


plt.figure()
plt.imshow(cov_matrix, cmap='viridis')
plt.colorbar()
plt.title('Spherical covariance matrix')
plt.xlabel('SH signal index')
plt.ylabel('SH signal index')
plt.show()

# Weights calculation
wnm = sphericalBF.SH_MVDR_weights(N_harm, Y_s, cov_matrix)

pnm = SHutils.transform_SH(y, el, az, SH_order)
#pnm_ = SHutils.signal2SH(y, SH_order, el, az)

# SH Signal after Beamforming
BF_signal = wnm[:,0].T @ pnm

# %% Check results
# Signal normalization
BF_signal_norm = BF_signal / np.max(np.abs(BF_signal))

plt.figure()
plt.plot(y_before, label='Before BF')
plt.plot(BF_signal_norm, label='After BF')
plt.xlabel('Samples')
plt.ylabel('Amplitude')
plt.legend()

print('-------------------SH---------------------')
# SNR BEFORE BEAMFORMING
noise_before = np.var(y_before[0:150000]) # Noise samples (without voice)
power_before = np.var(y_before[170000:580000]) # Voice samples
SNR_before = utils.calculates_SNR(power_before, noise_before)
print('SNR(before BF) = ' + str(SNR_before) + ' dB')

# SNR AFTER BEAMFORMING
noise_after = np.var(BF_signal_norm[0:150000]) # Noise samples (without voice)
power_after = np.var(BF_signal_norm[170000:580000]) # Voice samples
SNR_after = utils.calculates_SNR(power_after, noise_after)
print('SNR(after BF) = ' + str(SNR_after) + ' dB')

# SIGNAL-TO-DISTORSION-RATIO
sdr = utils.calculates_SDR(y_before, BF_signal_norm)
print('SDR = ' + str(sdr) + ' dB')

# PESQ
# Resampling to 16 kHz
fs_res = 16000
num_samples_ref = int(len(y_before) * fs_res / fs)
num_samples_proc = int(len(BF_signal_norm) * fs_res / fs)
before_resampled = resample(y_before, num_samples_ref)
after_resampled = resample(BF_signal_norm, num_samples_proc)
PESQ = pesq(fs_res, before_resampled, after_resampled, 'wb')
print('PESQ = ' + str(PESQ))

# SAVE AS A WAV FILE
# Convert to 16-bit integer in order to save as a WAV
BF_signal_norm = np.int16(BF_signal_norm * 32767)

# Saving the wav file

# TEST 1
#wavfile.write('./results/zylia/signal_after.wav', fs, BF_signal_norm)
# TEST 2
wavfile.write('./results/zylia/test2/signal_after.wav', fs, BF_signal_norm)

# %% MVDR BF 3D visualization

# Sources' directions in cartesian coordenates  
src_cart = np.array(utils.sph2cart(1, az_s, el_s)).T # r=1 because is unit vector (otherwise r = r_pos_s)
# Resolution of the grid
aziRes = 5
elRes = 5

for i in range(L):
    # Visualization with sources' directions
    SH_visualization.plotSphFunctionCoeffs(wnm[:,i], SH_order, aziRes, elRes)
    plt.title('MVDR BF on source ' + str(i))
    for source in src_cart:
        plt.plot([0, source[0]], [0, source[1]], [0, source[2]], color='black', linewidth=2, linestyle='--')
 
# %% NTT BEAMFORMER RESULTS

# TEST 1
#fs, BF_signal_ntt  = wavfile.read('../NTT_MVDR/results/BF_NTT.wav')
# TEST 2
fs, BF_signal_ntt  = wavfile.read('../NTT_MVDR/results/test2/BF_NTT.wav')

BF_signal_ntt = BF_signal_ntt[1:] / np.max(np.abs(BF_signal_ntt[1:]))

BF_signal_norm = BF_signal_norm[1:]
y_before = y_before[1:]

print('-------------------NTT---------------------')
# SNR BEFORE BEAMFORMING
noise_before = np.var(y_before[0:1500000]) # Noise samples (without voice)
power_before = np.var(y_before[170000:580000]) # Voice samples
SNR_before = utils.calculates_SNR(power_before, noise_before)
print('SNR(before BF) = ' + str(SNR_before) + ' dB')

# SNR AFTER BEAMFORMING
noise_after = np.var(BF_signal_ntt[0:1500000]) # Noise samples (without voice)
power_after = np.var(BF_signal_ntt[170000:580000]) # Voice samples
SNR_after = utils.calculates_SNR(power_after, noise_after)
print('SNR(after BF) = ' + str(SNR_after) + ' dB')


plt.figure()
plt.plot(y_before, label='Before BF')
plt.plot(BF_signal_ntt, label='After BF')
plt.xlabel('Samples')
plt.ylabel('Amplitude')
plt.legend()


# SIGNAL-TO-DISTORSION-RATIO
sdr = utils.calculates_SDR(y_before, BF_signal_ntt)
print('SDR = ' + str(sdr) + ' dB')

# PESQ
# Resampling to 16 kHz
fs_res = 16000
num_samples_ref = int(len(y_before) * fs_res / fs)
num_samples_proc = int(len(BF_signal_ntt) * fs_res / fs)
before_resampled = resample(y_before, num_samples_ref)
after_resampled = resample(BF_signal_ntt, num_samples_proc)
PESQ = pesq(fs_res, before_resampled, after_resampled, 'wb')
print('PESQ = ' + str(PESQ))