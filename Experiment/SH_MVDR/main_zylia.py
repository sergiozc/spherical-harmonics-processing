# -*- coding: utf-8 -*-
"""
Created on Sat Jul 20 16:32:04 2024

@author: sergiozc
@references:
    - https://www.zylia.co/white-paper.html

MVDR beamformer in the Spherical Harmonics domain using a signal generated by ZYLIA ZM-1 HO MICROPHONE
"""

from utils import utils
import numpy as np
from scipy.io import loadmat
import pandas as pd
import matplotlib.pyplot as plt
from SH_visualize import SH_visualization
from SH_BF import sphericalBF
from sphericalHarmonic import SHutils
from scipy.io import wavfile

plt.close('all')

# %%
# PARAMETER DEFINITION

c = 343 # Propagation speed
r = 0.049 # Zylia radius
SH_order = 3 # Spherical harmonic order (it determines the complexity of the function)
# The higher is the order, the more directive is the beampattern
# Nevertheless, the higuer is the order, the  more spatial aliasing might we have
N_harm = (SH_order + 1) ** 2 # Highest number of harmonics

# Microphones' positions
pos_mic = pd.read_csv('input_data/zylia/pos_mics.txt')
el = np.array(np.deg2rad(pos_mic['el']))
az = np.array(np.deg2rad(pos_mic['az']))
Q = len(el) # Number of microphones
L = 1 # Number of sources

# MICROPHONES VISUALIZATION
# pos_mic_cart = np.array(utils.sph2cart(az, el, r))
# fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')
# ax.scatter(pos_mic_cart[0, :], pos_mic_cart[1, :], pos_mic_cart[2, :], c='b', marker='o', label='Microphones')
# ax.set_xlabel('X (m)')
# ax.set_ylabel('Y (m)')
# ax.set_zlabel('Z (m)')
# ax.legend()
# ax.set_title('Microphones positions')
# plt.show()

# Sources' positions
# Â¿SE COLOCA LA FUENTE JUSTO EN FRENTE?
el_s = np.array([np.pi/4])
az_s = np.array([np.pi])


# Load microphones' signals
y, fs = utils.load_wav_signals('input_data/zylia/')
# Signal normalization (one mic)
y_before = y[:,1]/ np.max(np.abs(y[:,1]))
# Convert to 16-bit integer in order to save as a WAV
y_wav = np.int16(y_before * 32767)
# Saving the wav file
wavfile.write('./results/zylia/signal_before.wav', fs, y_wav)

#%% MVDR Beamformer

# Sources Spherical Harmonics
Y_s = SHutils.realSH(SH_order, utils.el2inc(el_s), az_s) # d_n (steering vector)
# In SH domain, the steering vector of the beamformer is given by the spherical harmonics

# Power of the sources
power_s = np.eye(L) # We assume all sources have the same power


# Power of the noise (diffuse noise)
#power_noise = 1

# Power of the noise (within the record)
power_noise = np.var(y_before[0:90000]) # Noise samples (without voice)

# SH signal covariance matrix (N_harm x N_harm)
cov_matrix = sphericalBF.SH_COV(N_harm, Y_s, power_s, power_noise)


plt.figure()
plt.imshow(cov_matrix, cmap='viridis')
plt.colorbar()
plt.title('Spherical covariance matrix')
plt.xlabel('SH signal index')
plt.ylabel('SH signal index')
plt.show()

# Weights calculation
wnm = sphericalBF.SH_MVDR_weights(N_harm, Y_s, cov_matrix)

pnm = SHutils.transform_SH(y, el, az, SH_order)
#pnm_ = SHutils.signal2SH(y, SH_order, el, az)

# SH Signal after Beamforming
BF_signal = wnm[:,0].T @ pnm

# %% Check results
# Signal normalization
BF_signal_norm = BF_signal / np.max(np.abs(BF_signal))

plt.figure()
plt.plot(y_before, label='Before BF')
plt.plot(BF_signal_norm, label='After BF')
plt.xlabel('Samples')
plt.ylabel('Amplitude')
plt.legend()


# SNR BEFORE BEAMFORMING
noise_before = np.var(y_before[0:90000]) # Noise samples (without voice)
power_before = np.var(y_before[114000:400000]) # Voice samples
SNR_before = utils.calculates_SNR(power_before, noise_before)
print('SNR(before BF) = ' + str(SNR_before) + ' dB')

# SNR AFTER BEAMFORMING
noise_after = np.var(BF_signal_norm[0:90000]) # Noise samples (without voice)
power_after = np.var(BF_signal_norm[114000:400000]) # Voice samples
SNR_after = utils.calculates_SNR(power_after, noise_after)
print('SNR(after BF) = ' + str(SNR_after) + ' dB')

# SAVE AS A WAV FILE
# Convert to 16-bit integer in order to save as a WAV
BF_signal_norm = np.int16(BF_signal_norm * 32767)
# Saving the wav file
wavfile.write('./results/zylia/signal_after.wav', fs, BF_signal_norm)

# %% MVDR BF 3D visualization

# Sources' directions in cartesian coordenates  
src_cart = np.array(utils.sph2cart(1, az_s, el_s)).T # r=1 because is unit vector (otherwise r = r_pos_s)
# Resolution of the grid
aziRes = 5
elRes = 5

for i in range(L):
    # Visualization with sources' directions
    SH_visualization.plotSphFunctionCoeffs(wnm[:,i], SH_order, aziRes, elRes)
    plt.title('MVDR BF on source ' + str(i))
    for source in src_cart:
        plt.plot([0, source[0]], [0, source[1]], [0, source[2]], color='black', linewidth=2, linestyle='--')
 