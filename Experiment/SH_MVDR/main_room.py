# -*- coding: utf-8 -*-
"""
Created on Sun Jul 14 16:23:27 2024

@author: sergiozc

MVDR beamformer in the Spherical Harmonics domain using a signal generated by Roomsimove.
"""

from utils import utils
import numpy as np
from scipy.io import loadmat
import matplotlib.pyplot as plt
from SH_visualize import SH_visualization
from SH_BF import sphericalBF
from sphericalHarmonic import SHutils
from scipy.io import wavfile
from pesq import pesq
from scipy.signal import resample

plt.close('all')

# %%
# PARAMETER DEFINITION

c = 343 # Propagation speed
r = 0.049 # Assuming same radius
room_size = np.array([5, 4, 2.6]) # Room dimensions
SH_order = 6 # Spherical harmonic order (it determines the complexity of the function)
# The higher is the order, the more directive is the beampattern
# Nevertheless, the higuer is the order, the  more spatial aliasing might we have
Nmin = 0 # Lowest order (default 0)
N_harm = (SH_order + 1) ** 2 # Highest number of harmonics (not valid if Nmin != 0)

# Microphones' positions
pos_mic = loadmat('input_data/pos_mic.mat')['pos_mic'] # Microphones positions (x,y,z)
Q = pos_mic.shape[0]  # Number of microphones (selecting rows' length) 
el = np.zeros(Q) # Mic elevation
az = np.zeros(Q) # Mic azimut
r_pos_mic = np.zeros(Q) # Distance vector for microphones
for i, (x, y, z) in enumerate(pos_mic): # Switch to el and az (from cartesian)
    el[i], az[i], r_pos_mic[i] = utils.cart2sph(x, y, z)

# Sources' positions
pos_sources = loadmat('input_data/pos_sources.mat')['pos_sources'] # Sources positions (x,y,z)
L = pos_sources.shape[0]  # Number of sources (selecting rows' length)
el_s = np.zeros(L) # Sources elevation
az_s = np.zeros(L) # Sources azimut
r_pos_s = np.zeros(L) # Distance vector (r) for sources
for j, (x_s, y_s, z_s) in enumerate(pos_sources):# Switch to el and az (from cartesian)
    el_s[j], az_s[j], r_pos_s[j] = utils.cart2sph(x_s, y_s, z_s)
    
    
# MICROPHONES AND SOURCES SPATIAL VISUALIZATION
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(pos_mic[:, 0], pos_mic[:, 1], pos_mic[:, 2], c='b', marker='o', label='Microphones')
ax.scatter(pos_sources[0, 0], pos_sources[0, 1], pos_sources[0, 2], c='r', marker='o', label='Source')
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_xlim([0, room_size[0]])
ax.set_ylim([0, room_size[1]])
ax.set_zlim([0, room_size[2]])
ax.legend()
ax.set_title('Microphones and sources positions')
plt.show()

# Frequency values (not used)
freq_array = loadmat('input_data/freq.mat')['freq_array'] # Frequency array
freq_array[0] = 1 # To avoid dividing by zero
k_array = SHutils.getK(freq_array, c) # Wavenumber array
Nfreq = len(k_array) # Number of frequencies

# Sound pressure and timeframes
P = loadmat('input_data/sound_pressure.mat')['P'] # Sound pressure
timeFrames = P.shape[2] # Number of time frames

fs = 16000 # Sample rate
Q = 19 # Number of microphones
Nfft = 512  # FFT size for STFT

# Recorded signal from mics
y = loadmat('input_data/y.mat')['y_noise']
# Signal normalization (one mic)
y_before = y[:,1]/ np.max(np.abs(y[:,1]))
# Convert to 16-bit integer in order to save as a WAV
y_wav = np.int16(y_before * 32767)
# Saving the wav file
wavfile.write('./results/signal_room_before.wav', fs, y_wav)

# Original source (simulation)
_, source_signal = wavfile.read('input_data/source_room.wav')



#%% MVDR Beamformer

# Sources Spherical Harmonics
Y_s = SHutils.realSH(SH_order, utils.el2inc(el_s), az_s) # d_n (steering vector)
# In SH domain, the steering vector of the beamformer is given by the spherical harmonics

# Power of the sources
#power_s = np.eye(L) # We assume all sources have the same power

# DIFFERENT POWERS
#powers = np.array([1, 3, 5, 1])
#power_s = np.diag(powers)

# SIMULATION
power_source = utils.calculates_power(source_signal)
power_s = np.diag(np.array([power_source]))

# Power of the noise (diffuse noise)
#power_noise = 1

# Power of the noise (within the record)
power_noise = np.var(y_before[120000:121000]) # Noise samples (without voice)

# SH signal covariance matrix (N_harm x N_harm)
cov_matrix = sphericalBF.SH_COV(N_harm, Y_s, power_s, power_noise)


plt.figure()
plt.imshow(cov_matrix, cmap='viridis')
plt.colorbar()
plt.title('Spherical covariance matrix')
plt.xlabel('SH signal index')
plt.ylabel('SH signal index')
plt.show()

# Weights calculation
wnm = sphericalBF.SH_MVDR_weights(N_harm, Y_s, cov_matrix)

pnm = SHutils.transform_SH(y, el, az, SH_order)
#pnm_ = SHutils.signal2SH(y, SH_order, el, az)

# SH Signal after Beamforming
BF_signal = wnm[:,0].T @ pnm

# %% Check results
# Signal normalization
BF_signal_norm = BF_signal / np.max(np.abs(BF_signal))

plt.figure()
plt.plot(y_before, label='Before BF')
plt.plot(BF_signal_norm, label='After BF')
plt.xlabel('Samples')
plt.ylabel('Amplitude')
plt.legend()


# SNR BEFORE BEAMFORMING
noise_before = np.var(y_before[120000:121000]) # Noise samples (without voice)
power_before = np.var(y_before[2000:120000]) # Voice samples
SNR_before = utils.calculates_SNR(power_before, noise_before)
print('SNR(before BF) = ' + str(SNR_before) + ' dB')

# SNR AFTER BEAMFORMING
noise_after = np.var(BF_signal_norm[120000:121000]) # Noise samples (without voice)
power_after = np.var(BF_signal_norm[2000:120000]) # Voice samples
SNR_after = utils.calculates_SNR(power_after, noise_after)
print('SNR(after BF) = ' + str(SNR_after) + ' dB')

# SIGNAL-TO-DISTORSION-RATIO
sdr = utils.calculates_SDR(y_before, BF_signal_norm)
print('SDR = ' + str(sdr) + ' dB')

# PESQ
# Resampling to 16 kHz
fs_res = 16000
num_samples_ref = int(len(y_before) * fs_res / fs)
num_samples_proc = int(len(BF_signal_norm) * fs_res / fs)
before_resampled = resample(y_before, num_samples_ref)
after_resampled = resample(BF_signal_norm, num_samples_proc)
PESQ = pesq(fs_res, before_resampled, after_resampled, 'wb')
print('PESQ = ' + str(PESQ))

# SAVE AS A WAV FILE
# Convert to 16-bit integer in order to save as a WAV
BF_signal_norm = np.int16(BF_signal_norm * 32767)
# Saving the wav file
wavfile.write('./results/signal_room_after.wav', fs, BF_signal_norm)


# %% MVDR BF 3D visualization

# Sources' directions in cartesian coordenates  
src_cart = np.array(utils.sph2cart(1, az_s, el_s)).T # r=1 because is unit vector (otherwise r = r_pos_s)
# Resolution of the grid
aziRes = 5
elRes = 5

for i in range(L):
    # Visualization with sources' directions
    SH_visualization.plotSphFunctionCoeffs(wnm[:,i], SH_order, aziRes, elRes)
    plt.title('MVDR BF on source ' + str(i))
    for source in src_cart:
        plt.plot([0, source[0]], [0, source[1]], [0, source[2]], color='black', linewidth=2, linestyle='--')
 
